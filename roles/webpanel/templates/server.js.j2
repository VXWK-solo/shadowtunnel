const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const bodyParser = require('body-parser');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const sqlite3 = require('sqlite3').verbose();
const WebSocket = require('ws');
const si = require('systeminformation');
const cron = require('node-cron');
const path = require('path');
const fs = require('fs');

const app = express();
const PORT = {{ web_panel.port | default(2053) }};

// Security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
}));

app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.'
});
app.use(limiter);

// Serve static files
app.use(express.static(path.join(__dirname, 'public')));

// Database initialization
const db = new sqlite3.Database(':memory:');
db.serialize(() => {
  db.run(`CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE,
    password TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);
  
  db.run(`CREATE TABLE IF NOT EXISTS sessions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    token TEXT,
    expires_at DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(user_id) REFERENCES users(id)
  )`);
  
  db.run(`CREATE TABLE IF NOT EXISTS logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    level TEXT,
    message TEXT,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);
});

// JWT secret
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-this';

// Authentication middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid token' });
    }
    req.user = user;
    next();
  });
};

// API Routes
app.post('/api/login', async (req, res) => {
  const { username, password } = req.body;
  
  if (!username || !password) {
    return res.status(400).json({ error: 'Username and password required' });
  }

  db.get('SELECT * FROM users WHERE username = ?', [username], async (err, user) => {
    if (err) {
      return res.status(500).json({ error: 'Database error' });
    }

    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const token = jwt.sign({ userId: user.id, username: user.username }, JWT_SECRET, { expiresIn: '24h' });
    
    res.json({
      token,
      user: {
        id: user.id,
        username: user.username
      }
    });
  });
});

app.get('/api/status', authenticateToken, async (req, res) => {
  try {
    const systemInfo = await si.getStaticData();
    const currentLoad = await si.currentLoad();
    const memInfo = await si.mem();
    const networkStats = await si.networkStats();
    
    res.json({
      system: {
        platform: systemInfo.platform,
        distro: systemInfo.distro,
        release: systemInfo.release,
        arch: systemInfo.arch,
        hostname: systemInfo.hostname,
        uptime: systemInfo.uptime
      },
      performance: {
        cpu: currentLoad,
        memory: memInfo,
        network: networkStats
      },
      services: {
        xray: await checkServiceStatus('xray'),
        v2ray: await checkServiceStatus('v2ray'),
        nginx: await checkServiceStatus('nginx')
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to get system status' });
  }
});

app.get('/api/users', authenticateToken, (req, res) => {
  // Read users from config
  try {
    const configPath = '/etc/xray/config.json';
    const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    
    const users = [];
    config.inbounds.forEach(inbound => {
      if (inbound.settings && inbound.settings.clients) {
        inbound.settings.clients.forEach(client => {
          users.push({
            id: client.id || client.password,
            email: client.email,
            protocol: inbound.protocol,
            port: inbound.port
          });
        });
      }
    });
    
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: 'Failed to read users' });
  }
});

app.post('/api/users', authenticateToken, (req, res) => {
  const { username, protocol } = req.body;
  
  // Generate new user configuration
  const userId = generateUserId();
  
  // Update Xray configuration
  updateXrayConfig(userId, username, protocol);
  
  res.json({ success: true, userId });
});

app.delete('/api/users/:id', authenticateToken, (req, res) => {
  const { id } = req.params;
  
  // Remove user from configuration
  removeUserFromConfig(id);
  
  res.json({ success: true });
});

app.get('/api/logs', authenticateToken, (req, res) => {
  const { level, limit = 100 } = req.query;
  
  let query = 'SELECT * FROM logs';
  let params = [];
  
  if (level) {
    query += ' WHERE level = ?';
    params.push(level);
  }
  
  query += ' ORDER BY timestamp DESC LIMIT ?';
  params.push(parseInt(limit));
  
  db.all(query, params, (err, rows) => {
    if (err) {
      return res.status(500).json({ error: 'Database error' });
    }
    res.json(rows);
  });
});

// WebSocket for real-time updates
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
  console.log('WebSocket client connected');
  
  ws.on('close', () => {
    console.log('WebSocket client disconnected');
  });
});

// Utility functions
async function checkServiceStatus(serviceName) {
  try {
    const { exec } = require('child_process');
    return new Promise((resolve) => {
      exec(`systemctl is-active ${serviceName}`, (error, stdout) => {
        resolve(stdout.trim() === 'active');
      });
    });
  } catch (error) {
    return false;
  }
}

function generateUserId() {
  return require('crypto').randomUUID();
}

function updateXrayConfig(userId, username, protocol) {
  // Implementation for updating Xray configuration
  console.log(`Adding user ${username} with ID ${userId} for protocol ${protocol}`);
}

function removeUserFromConfig(userId) {
  // Implementation for removing user from configuration
  console.log(`Removing user with ID ${userId}`);
}

// Cron job for system monitoring
cron.schedule('*/5 * * * *', async () => {
  try {
    const status = await si.currentLoad();
    const memInfo = await si.mem();
    
    // Broadcast to WebSocket clients
    wss.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(JSON.stringify({
          type: 'system_update',
          data: {
            cpu: status,
            memory: memInfo,
            timestamp: new Date().toISOString()
          }
        }));
      }
    });
  } catch (error) {
    console.error('Error in monitoring cron job:', error);
  }
});

// Initialize default admin user
const defaultPassword = '{{ web_panel.password | default("admin123") }}';
const hashedPassword = bcrypt.hashSync(defaultPassword, 10);

db.run('INSERT OR IGNORE INTO users (username, password) VALUES (?, ?)', 
  ['{{ web_panel.username | default("admin") }}', hashedPassword]);

// Start server
app.listen(PORT, () => {
  console.log(`Advanced VPN Panel running on port ${PORT}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  db.close();
  process.exit(0);
});
